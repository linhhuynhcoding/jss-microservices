// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: crud.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsageRecordsByVoucherId = `-- name: CountUsageRecordsByVoucherId :one
SELECT COUNT(*)
FROM usage_records
WHERE voucher_id = $1
`

func (q *Queries) CountUsageRecordsByVoucherId(ctx context.Context, voucherID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countUsageRecordsByVoucherId, voucherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomerVoucher = `-- name: CreateCustomerVoucher :one
INSERT INTO customer_vouchers (customer_id, voucher_id, status, used_at)
VALUES ($1, $2, $3, $4)
RETURNING id, customer_id, voucher_id, status, used_at
`

type CreateCustomerVoucherParams struct {
	CustomerID string           `json:"customer_id"`
	VoucherID  int32            `json:"voucher_id"`
	Status     pgtype.Text      `json:"status"`
	UsedAt     pgtype.Timestamp `json:"used_at"`
}

func (q *Queries) CreateCustomerVoucher(ctx context.Context, arg CreateCustomerVoucherParams) (CustomerVoucher, error) {
	row := q.db.QueryRow(ctx, createCustomerVoucher,
		arg.CustomerID,
		arg.VoucherID,
		arg.Status,
		arg.UsedAt,
	)
	var i CustomerVoucher
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VoucherID,
		&i.Status,
		&i.UsedAt,
	)
	return i, err
}

const createLoyaltyPoint = `-- name: CreateLoyaltyPoint :one
INSERT INTO loyalty_points (customer_id, points, source, reference_id, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, customer_id, points, source, reference_id, created_at
`

type CreateLoyaltyPointParams struct {
	CustomerID  string           `json:"customer_id"`
	Points      pgtype.Int4      `json:"points"`
	Source      string           `json:"source"`
	ReferenceID pgtype.Int4      `json:"reference_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateLoyaltyPoint(ctx context.Context, arg CreateLoyaltyPointParams) (LoyaltyPoint, error) {
	row := q.db.QueryRow(ctx, createLoyaltyPoint,
		arg.CustomerID,
		arg.Points,
		arg.Source,
		arg.ReferenceID,
		arg.CreatedAt,
	)
	var i LoyaltyPoint
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Points,
		&i.Source,
		&i.ReferenceID,
		&i.CreatedAt,
	)
	return i, err
}

const createVoucher = `-- name: CreateVoucher :one
INSERT INTO vouchers (code, description, discount_type, discount_value, start_date, end_date, usage_limit, created_at, is_global)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, code, description, discount_type, discount_value, start_date, end_date, usage_limit, is_global, created_at
`

type CreateVoucherParams struct {
	Code          string           `json:"code"`
	Description   pgtype.Text      `json:"description"`
	DiscountType  string           `json:"discount_type"`
	DiscountValue pgtype.Numeric   `json:"discount_value"`
	StartDate     pgtype.Date      `json:"start_date"`
	EndDate       pgtype.Date      `json:"end_date"`
	UsageLimit    pgtype.Int4      `json:"usage_limit"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	IsGlobal      pgtype.Bool      `json:"is_global"`
}

func (q *Queries) CreateVoucher(ctx context.Context, arg CreateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, createVoucher,
		arg.Code,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.StartDate,
		arg.EndDate,
		arg.UsageLimit,
		arg.CreatedAt,
		arg.IsGlobal,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.IsGlobal,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCustomerVoucher = `-- name: DeleteCustomerVoucher :exec
DELETE FROM customer_vouchers
WHERE id = $1
`

func (q *Queries) DeleteCustomerVoucher(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCustomerVoucher, id)
	return err
}

const deleteLoyaltyPoint = `-- name: DeleteLoyaltyPoint :exec
DELETE FROM loyalty_points
WHERE id = $1
`

func (q *Queries) DeleteLoyaltyPoint(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLoyaltyPoint, id)
	return err
}

const deleteVoucher = `-- name: DeleteVoucher :exec
DELETE FROM vouchers
WHERE id = $1
`

func (q *Queries) DeleteVoucher(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVoucher, id)
	return err
}

const getActiveVouchers = `-- name: GetActiveVouchers :many
SELECT id, code, description, discount_type, discount_value, start_date, end_date, usage_limit, is_global, created_at FROM vouchers
WHERE start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetActiveVouchersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetActiveVouchers(ctx context.Context, arg GetActiveVouchersParams) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, getActiveVouchers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.StartDate,
			&i.EndDate,
			&i.UsageLimit,
			&i.IsGlobal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCustomerVouchers = `-- name: GetAllCustomerVouchers :many
SELECT cv.id, cv.customer_id, cv.voucher_id, cv.status, cv.used_at, v.code, v.description, v.discount_type, v.discount_value, v.start_date, v.end_date
FROM customer_vouchers cv
JOIN vouchers v ON cv.voucher_id = v.id
ORDER BY cv.id DESC
LIMIT $1 OFFSET $2
`

type GetAllCustomerVouchersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllCustomerVouchersRow struct {
	ID            int32            `json:"id"`
	CustomerID    string           `json:"customer_id"`
	VoucherID     int32            `json:"voucher_id"`
	Status        pgtype.Text      `json:"status"`
	UsedAt        pgtype.Timestamp `json:"used_at"`
	Code          string           `json:"code"`
	Description   pgtype.Text      `json:"description"`
	DiscountType  string           `json:"discount_type"`
	DiscountValue pgtype.Numeric   `json:"discount_value"`
	StartDate     pgtype.Date      `json:"start_date"`
	EndDate       pgtype.Date      `json:"end_date"`
}

func (q *Queries) GetAllCustomerVouchers(ctx context.Context, arg GetAllCustomerVouchersParams) ([]GetAllCustomerVouchersRow, error) {
	rows, err := q.db.Query(ctx, getAllCustomerVouchers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCustomerVouchersRow{}
	for rows.Next() {
		var i GetAllCustomerVouchersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.VoucherID,
			&i.Status,
			&i.UsedAt,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLoyaltyPoints = `-- name: GetAllLoyaltyPoints :many
SELECT id, customer_id, points, source, reference_id, created_at FROM loyalty_points
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllLoyaltyPointsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllLoyaltyPoints(ctx context.Context, arg GetAllLoyaltyPointsParams) ([]LoyaltyPoint, error) {
	rows, err := q.db.Query(ctx, getAllLoyaltyPoints, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoyaltyPoint{}
	for rows.Next() {
		var i LoyaltyPoint
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Points,
			&i.Source,
			&i.ReferenceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVouchers = `-- name: GetAllVouchers :many
SELECT id, code, description, discount_type, discount_value, start_date, end_date, usage_limit, is_global, created_at FROM vouchers
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllVouchersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllVouchers(ctx context.Context, arg GetAllVouchersParams) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, getAllVouchers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.StartDate,
			&i.EndDate,
			&i.UsageLimit,
			&i.IsGlobal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableVouchersForCustomer = `-- name: GetAvailableVouchersForCustomer :many
SELECT v.id, v.code, v.description, v.discount_type, v.discount_value, v.start_date, v.end_date, v.usage_limit, v.is_global, v.created_at
FROM vouchers v
LEFT JOIN customer_vouchers cv ON v.id = cv.voucher_id AND cv.customer_id = $1
WHERE v.start_date <= CURRENT_DATE 
  AND v.end_date >= CURRENT_DATE
  AND (cv.id IS NULL OR cv.status = 'unused')
  AND (v.usage_limit IS NULL OR 
       (SELECT COUNT(*) FROM customer_vouchers WHERE voucher_id = v.id AND status = 'used') < v.usage_limit)
ORDER BY v.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAvailableVouchersForCustomerParams struct {
	CustomerID string `json:"customer_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) GetAvailableVouchersForCustomer(ctx context.Context, arg GetAvailableVouchersForCustomerParams) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, getAvailableVouchersForCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.StartDate,
			&i.EndDate,
			&i.UsageLimit,
			&i.IsGlobal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerTotalPoints = `-- name: GetCustomerTotalPoints :one
SELECT COALESCE(SUM(points), 0) as total_points
FROM loyalty_points
WHERE customer_id = $1
`

func (q *Queries) GetCustomerTotalPoints(ctx context.Context, customerID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getCustomerTotalPoints, customerID)
	var total_points interface{}
	err := row.Scan(&total_points)
	return total_points, err
}

const getCustomerVoucher = `-- name: GetCustomerVoucher :one
SELECT id, customer_id, voucher_id, status, used_at FROM customer_vouchers
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCustomerVoucher(ctx context.Context, id int32) (CustomerVoucher, error) {
	row := q.db.QueryRow(ctx, getCustomerVoucher, id)
	var i CustomerVoucher
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VoucherID,
		&i.Status,
		&i.UsedAt,
	)
	return i, err
}

const getCustomerVouchers = `-- name: GetCustomerVouchers :many
SELECT cv.id, cv.customer_id, cv.voucher_id, cv.status, cv.used_at, v.code, v.description, v.discount_type, v.discount_value, v.start_date, v.end_date, v.usage_limit, v.is_global
FROM customer_vouchers cv
JOIN vouchers v ON cv.voucher_id = v.id
WHERE cv.customer_id = $1
ORDER BY cv.id DESC
LIMIT $2 OFFSET $3
`

type GetCustomerVouchersParams struct {
	CustomerID string `json:"customer_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetCustomerVouchersRow struct {
	ID            int32            `json:"id"`
	CustomerID    string           `json:"customer_id"`
	VoucherID     int32            `json:"voucher_id"`
	Status        pgtype.Text      `json:"status"`
	UsedAt        pgtype.Timestamp `json:"used_at"`
	Code          string           `json:"code"`
	Description   pgtype.Text      `json:"description"`
	DiscountType  string           `json:"discount_type"`
	DiscountValue pgtype.Numeric   `json:"discount_value"`
	StartDate     pgtype.Date      `json:"start_date"`
	EndDate       pgtype.Date      `json:"end_date"`
	UsageLimit    pgtype.Int4      `json:"usage_limit"`
	IsGlobal      pgtype.Bool      `json:"is_global"`
}

func (q *Queries) GetCustomerVouchers(ctx context.Context, arg GetCustomerVouchersParams) ([]GetCustomerVouchersRow, error) {
	rows, err := q.db.Query(ctx, getCustomerVouchers, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomerVouchersRow{}
	for rows.Next() {
		var i GetCustomerVouchersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.VoucherID,
			&i.Status,
			&i.UsedAt,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.StartDate,
			&i.EndDate,
			&i.UsageLimit,
			&i.IsGlobal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerVouchersByStatus = `-- name: GetCustomerVouchersByStatus :many
SELECT cv.id, cv.customer_id, cv.voucher_id, cv.status, cv.used_at, v.code, v.description, v.discount_type, v.discount_value, v.start_date, v.end_date
FROM customer_vouchers cv
JOIN vouchers v ON cv.voucher_id = v.id
WHERE cv.customer_id = $1 AND cv.status = $2
ORDER BY cv.id DESC
LIMIT $3 OFFSET $4
`

type GetCustomerVouchersByStatusParams struct {
	CustomerID string      `json:"customer_id"`
	Status     pgtype.Text `json:"status"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetCustomerVouchersByStatusRow struct {
	ID            int32            `json:"id"`
	CustomerID    string           `json:"customer_id"`
	VoucherID     int32            `json:"voucher_id"`
	Status        pgtype.Text      `json:"status"`
	UsedAt        pgtype.Timestamp `json:"used_at"`
	Code          string           `json:"code"`
	Description   pgtype.Text      `json:"description"`
	DiscountType  string           `json:"discount_type"`
	DiscountValue pgtype.Numeric   `json:"discount_value"`
	StartDate     pgtype.Date      `json:"start_date"`
	EndDate       pgtype.Date      `json:"end_date"`
}

func (q *Queries) GetCustomerVouchersByStatus(ctx context.Context, arg GetCustomerVouchersByStatusParams) ([]GetCustomerVouchersByStatusRow, error) {
	rows, err := q.db.Query(ctx, getCustomerVouchersByStatus,
		arg.CustomerID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomerVouchersByStatusRow{}
	for rows.Next() {
		var i GetCustomerVouchersByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.VoucherID,
			&i.Status,
			&i.UsedAt,
			&i.Code,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoyaltyPoint = `-- name: GetLoyaltyPoint :one
SELECT id, customer_id, points, source, reference_id, created_at FROM loyalty_points
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLoyaltyPoint(ctx context.Context, id int32) (LoyaltyPoint, error) {
	row := q.db.QueryRow(ctx, getLoyaltyPoint, id)
	var i LoyaltyPoint
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Points,
		&i.Source,
		&i.ReferenceID,
		&i.CreatedAt,
	)
	return i, err
}

const getLoyaltyPointsByCustomer = `-- name: GetLoyaltyPointsByCustomer :many
SELECT id, customer_id, points, source, reference_id, created_at FROM loyalty_points
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetLoyaltyPointsByCustomerParams struct {
	CustomerID string `json:"customer_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) GetLoyaltyPointsByCustomer(ctx context.Context, arg GetLoyaltyPointsByCustomerParams) ([]LoyaltyPoint, error) {
	rows, err := q.db.Query(ctx, getLoyaltyPointsByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoyaltyPoint{}
	for rows.Next() {
		var i LoyaltyPoint
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Points,
			&i.Source,
			&i.ReferenceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoyaltyPointsBySource = `-- name: GetLoyaltyPointsBySource :many
SELECT id, customer_id, points, source, reference_id, created_at FROM loyalty_points
WHERE source = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetLoyaltyPointsBySourceParams struct {
	Source string `json:"source"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetLoyaltyPointsBySource(ctx context.Context, arg GetLoyaltyPointsBySourceParams) ([]LoyaltyPoint, error) {
	rows, err := q.db.Query(ctx, getLoyaltyPointsBySource, arg.Source, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoyaltyPoint{}
	for rows.Next() {
		var i LoyaltyPoint
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Points,
			&i.Source,
			&i.ReferenceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageRecordsByVoucherId = `-- name: GetUsageRecordsByVoucherId :many
SELECT u.customer_id, u.voucher_id, u.order_id, u.status, u.created_at, u.updated_at
FROM usage_records U
WHERE u.voucher_id = $1
LIMIT $2 OFFSET $3
`

type GetUsageRecordsByVoucherIdParams struct {
	VoucherID int32 `json:"voucher_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetUsageRecordsByVoucherId(ctx context.Context, arg GetUsageRecordsByVoucherIdParams) ([]UsageRecord, error) {
	rows, err := q.db.Query(ctx, getUsageRecordsByVoucherId, arg.VoucherID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageRecord{}
	for rows.Next() {
		var i UsageRecord
		if err := rows.Scan(
			&i.CustomerID,
			&i.VoucherID,
			&i.OrderID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoucher = `-- name: GetVoucher :one
SELECT id, code, description, discount_type, discount_value, start_date, end_date, usage_limit, is_global, created_at FROM vouchers
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVoucher(ctx context.Context, id int32) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucher, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.IsGlobal,
		&i.CreatedAt,
	)
	return i, err
}

const getVoucherByCode = `-- name: GetVoucherByCode :one
SELECT id, code, description, discount_type, discount_value, start_date, end_date, usage_limit, is_global, created_at FROM vouchers
WHERE code = $1 LIMIT 1
`

func (q *Queries) GetVoucherByCode(ctx context.Context, code string) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucherByCode, code)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.IsGlobal,
		&i.CreatedAt,
	)
	return i, err
}

const updateCustomerVoucherStatus = `-- name: UpdateCustomerVoucherStatus :one
UPDATE customer_vouchers
SET status = $2, used_at = $3
WHERE id = $1
RETURNING id, customer_id, voucher_id, status, used_at
`

type UpdateCustomerVoucherStatusParams struct {
	ID     int32            `json:"id"`
	Status pgtype.Text      `json:"status"`
	UsedAt pgtype.Timestamp `json:"used_at"`
}

func (q *Queries) UpdateCustomerVoucherStatus(ctx context.Context, arg UpdateCustomerVoucherStatusParams) (CustomerVoucher, error) {
	row := q.db.QueryRow(ctx, updateCustomerVoucherStatus, arg.ID, arg.Status, arg.UsedAt)
	var i CustomerVoucher
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VoucherID,
		&i.Status,
		&i.UsedAt,
	)
	return i, err
}

const updateLoyaltyPoints = `-- name: UpdateLoyaltyPoints :one
UPDATE loyalty_points
SET points = $2, source = $3, reference_id = $4
WHERE id = $1
RETURNING id, customer_id, points, source, reference_id, created_at
`

type UpdateLoyaltyPointsParams struct {
	ID          int32       `json:"id"`
	Points      pgtype.Int4 `json:"points"`
	Source      string      `json:"source"`
	ReferenceID pgtype.Int4 `json:"reference_id"`
}

func (q *Queries) UpdateLoyaltyPoints(ctx context.Context, arg UpdateLoyaltyPointsParams) (LoyaltyPoint, error) {
	row := q.db.QueryRow(ctx, updateLoyaltyPoints,
		arg.ID,
		arg.Points,
		arg.Source,
		arg.ReferenceID,
	)
	var i LoyaltyPoint
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Points,
		&i.Source,
		&i.ReferenceID,
		&i.CreatedAt,
	)
	return i, err
}

const updateVoucher = `-- name: UpdateVoucher :one
UPDATE vouchers
SET code = $2, description = $3, discount_type = $4, discount_value = $5, 
    start_date = $6, end_date = $7, usage_limit = $8
WHERE id = $1
RETURNING id, code, description, discount_type, discount_value, start_date, end_date, usage_limit, is_global, created_at
`

type UpdateVoucherParams struct {
	ID            int32          `json:"id"`
	Code          string         `json:"code"`
	Description   pgtype.Text    `json:"description"`
	DiscountType  string         `json:"discount_type"`
	DiscountValue pgtype.Numeric `json:"discount_value"`
	StartDate     pgtype.Date    `json:"start_date"`
	EndDate       pgtype.Date    `json:"end_date"`
	UsageLimit    pgtype.Int4    `json:"usage_limit"`
}

func (q *Queries) UpdateVoucher(ctx context.Context, arg UpdateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, updateVoucher,
		arg.ID,
		arg.Code,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.StartDate,
		arg.EndDate,
		arg.UsageLimit,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.IsGlobal,
		&i.CreatedAt,
	)
	return i, err
}

const useCustomerVoucher = `-- name: UseCustomerVoucher :one
UPDATE customer_vouchers
SET status = 'used', used_at = $2
WHERE id = $1
RETURNING id, customer_id, voucher_id, status, used_at
`

type UseCustomerVoucherParams struct {
	ID     int32            `json:"id"`
	UsedAt pgtype.Timestamp `json:"used_at"`
}

func (q *Queries) UseCustomerVoucher(ctx context.Context, arg UseCustomerVoucherParams) (CustomerVoucher, error) {
	row := q.db.QueryRow(ctx, useCustomerVoucher, arg.ID, arg.UsedAt)
	var i CustomerVoucher
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VoucherID,
		&i.Status,
		&i.UsedAt,
	)
	return i, err
}
