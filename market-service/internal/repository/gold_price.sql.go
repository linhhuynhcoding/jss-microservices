// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: gold_price.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countGoldPrices = `-- name: CountGoldPrices :one
SELECT COUNT(*) FROM gold_prices
`

func (q *Queries) CountGoldPrices(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countGoldPrices)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGoldPricesByType = `-- name: CountGoldPricesByType :one
SELECT COUNT(*) FROM gold_prices
WHERE gold_type = $1
`

func (q *Queries) CountGoldPricesByType(ctx context.Context, goldType string) (int64, error) {
	row := q.db.QueryRow(ctx, countGoldPricesByType, goldType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGoldPrice = `-- name: CreateGoldPrice :one
INSERT INTO gold_prices (date, gold_type, buy_price, sell_price)
VALUES ($1, $2, $3, $4)
RETURNING id, date, gold_id, gold_type, buy_price, sell_price
`

type CreateGoldPriceParams struct {
	Date      pgtype.Timestamp `json:"date"`
	GoldType  string           `json:"gold_type"`
	BuyPrice  pgtype.Numeric   `json:"buy_price"`
	SellPrice pgtype.Numeric   `json:"sell_price"`
}

func (q *Queries) CreateGoldPrice(ctx context.Context, arg CreateGoldPriceParams) (GoldPrice, error) {
	row := q.db.QueryRow(ctx, createGoldPrice,
		arg.Date,
		arg.GoldType,
		arg.BuyPrice,
		arg.SellPrice,
	)
	var i GoldPrice
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.GoldID,
		&i.GoldType,
		&i.BuyPrice,
		&i.SellPrice,
	)
	return i, err
}

const deleteGoldPrice = `-- name: DeleteGoldPrice :exec
DELETE FROM gold_prices
WHERE id = $1
`

func (q *Queries) DeleteGoldPrice(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteGoldPrice, id)
	return err
}

const getGoldPrice = `-- name: GetGoldPrice :one
SELECT id, date, gold_id, gold_type, buy_price, sell_price FROM gold_prices
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetGoldPrice(ctx context.Context, id int32) (GoldPrice, error) {
	row := q.db.QueryRow(ctx, getGoldPrice, id)
	var i GoldPrice
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.GoldID,
		&i.GoldType,
		&i.BuyPrice,
		&i.SellPrice,
	)
	return i, err
}

const getGoldPrices = `-- name: GetGoldPrices :many
SELECT id, date, gold_id, gold_type, buy_price, sell_price FROM gold_prices
ORDER BY date DESC
LIMIT $1 OFFSET $2
`

type GetGoldPricesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetGoldPrices(ctx context.Context, arg GetGoldPricesParams) ([]GoldPrice, error) {
	rows, err := q.db.Query(ctx, getGoldPrices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GoldPrice{}
	for rows.Next() {
		var i GoldPrice
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.GoldID,
			&i.GoldType,
			&i.BuyPrice,
			&i.SellPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGoldPricesByType = `-- name: GetGoldPricesByType :many
SELECT id, date, gold_id, gold_type, buy_price, sell_price FROM gold_prices
WHERE gold_type = $1
ORDER BY date DESC
LIMIT $2 OFFSET $3
`

type GetGoldPricesByTypeParams struct {
	GoldType string `json:"gold_type"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) GetGoldPricesByType(ctx context.Context, arg GetGoldPricesByTypeParams) ([]GoldPrice, error) {
	rows, err := q.db.Query(ctx, getGoldPricesByType, arg.GoldType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GoldPrice{}
	for rows.Next() {
		var i GoldPrice
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.GoldID,
			&i.GoldType,
			&i.BuyPrice,
			&i.SellPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestGoldPrices = `-- name: GetLatestGoldPrices :many
SELECT DISTINCT ON (gold_id) id, date, gold_id, gold_type, buy_price, sell_price
FROM gold_prices
ORDER BY gold_id, date DESC
`

func (q *Queries) GetLatestGoldPrices(ctx context.Context) ([]GoldPrice, error) {
	rows, err := q.db.Query(ctx, getLatestGoldPrices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GoldPrice{}
	for rows.Next() {
		var i GoldPrice
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.GoldID,
			&i.GoldType,
			&i.BuyPrice,
			&i.SellPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGoldPrice = `-- name: UpdateGoldPrice :one
UPDATE gold_prices
SET date = $2, gold_type = $3, buy_price = $4, sell_price = $5
WHERE id = $1
RETURNING id, date, gold_id, gold_type, buy_price, sell_price
`

type UpdateGoldPriceParams struct {
	ID        int32            `json:"id"`
	Date      pgtype.Timestamp `json:"date"`
	GoldType  string           `json:"gold_type"`
	BuyPrice  pgtype.Numeric   `json:"buy_price"`
	SellPrice pgtype.Numeric   `json:"sell_price"`
}

func (q *Queries) UpdateGoldPrice(ctx context.Context, arg UpdateGoldPriceParams) (GoldPrice, error) {
	row := q.db.QueryRow(ctx, updateGoldPrice,
		arg.ID,
		arg.Date,
		arg.GoldType,
		arg.BuyPrice,
		arg.SellPrice,
	)
	var i GoldPrice
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.GoldID,
		&i.GoldType,
		&i.BuyPrice,
		&i.SellPrice,
	)
	return i, err
}

const upsertPrice = `-- name: UpsertPrice :one
INSERT INTO gold_prices (date, gold_id, gold_type, buy_price, sell_price)
	VALUES ($1, $2, $3, $4, $5)
RETURNING id, date, gold_id, gold_type, buy_price, sell_price
`

type UpsertPriceParams struct {
	Date      pgtype.Timestamp `json:"date"`
	GoldID    int32            `json:"gold_id"`
	GoldType  string           `json:"gold_type"`
	BuyPrice  pgtype.Numeric   `json:"buy_price"`
	SellPrice pgtype.Numeric   `json:"sell_price"`
}

func (q *Queries) UpsertPrice(ctx context.Context, arg UpsertPriceParams) (GoldPrice, error) {
	row := q.db.QueryRow(ctx, upsertPrice,
		arg.Date,
		arg.GoldID,
		arg.GoldType,
		arg.BuyPrice,
		arg.SellPrice,
	)
	var i GoldPrice
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.GoldID,
		&i.GoldType,
		&i.BuyPrice,
		&i.SellPrice,
	)
	return i, err
}
